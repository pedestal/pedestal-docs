= Using Pedestal With Component
Daniel De Aguiar
2016-09-11
:jbake-type: page
:toc: macro
:icons: font
:section: reference

ifdef::env-github,env-browser[:outfilessuffix: .adoc]

toc::[]
_by {author}_, _{revdate}_

== What You Will Learn
After reading this guide you will be able to:

- Create a Component-based service using Pedestal.
- Test your service using Pedestal's test helpers.

== Guide Assumptions
This guide is for users who are familiar with Clojure, Pedestal,
Component and Boot. If you are new to Pedestal, you may want to go back to the
link:hello-world[Hello World guide]. If you're new to Component, you
should definitely https://github.com/stuartsierra/component[check it
out] first.

== Getting Help if You're Stuck
If you get stuck at any point in this guide, please submit an
https://github.com/pedestal/docs/issues[issue] about this guide or hop
over to the
https://groups.google.com/forum/#!forum/pedestal-users[mailing list]
and raise your hand there.

This guide shows fragments of code as we add them. Sometimes it helps
to see the whole thing at once, so you can always check out
<<_the_whole_shebang,the whole shebang>> at the end of this guide.

== Where We Are Going
In this guide, we're going to step through creating a Pedestal service
using Component. We'll start off by creating a Pedestal component and
wire it into a Component system map. We'll then proceed to testing our
service.

== Before We Begin
What responsibilities do we want the Pedestal component to have? For
the purposes of this guide, it should only be responsible for the
initialization of the Pedestal Provider and starting of the
server. It's configuration, the Pedestal service map, should be a
component dependency and should not be managed by the Pedestal
component.

The Pedestal component should also be amiable to testing through
Pedestal's testing facilities. This should only require a Pedestal
service-fn to be available.

== A Simple Pedestal Component

Let's start with the Pedestal component. Create a `src` directory with
a `pedestal.clj` file.

[source, clojure]
.src/pedestal.clj

----
include::component/src/pedestal.clj[tags=ns]
----
<1> Create a _pedestal_ namespace to house the Pedestal component.
<2> We need to require `com.stuartsierra.component` to implement the
`start` and `stop` `Lifecycle` methods.
<3> We need to require the `io.pedestal.http` for server creation,
starting and stopping.

Let's start implementing the component.
----
include::component/src/pedestal.clj[tags=component-init]
----
<1> Create a _Pedestal_ record. This record will contain a number of
 fields, the first field is _service-map_ which will hold the Pedestal
 service map component dependency.
<2> The next field is _start-fn_, this will be passed in through the
 component constructor and will be used to start the Pedestal
 server. This function must accept one parameter, the Pedestal service
 map, and return a Pedestal service map.
<3> The next field is _stop-fn_, like _start-fn_, the stop function
 will be passed in through the component constructor. It's responsible
 for stopping the Pedestal server. This function must accept one
 parameter, the Pedestal service map, and return a Pedestal service map.
<4> The _service_ field is created as part of the component
 initialization process.
<2> Include the _component/Lifecycle_ protocol since we'll be
implementing it's methods next.

We'll first implement the `start` method.
----
include::component/src/pedestal.clj[tags=component-start]
----
<1> The _start_ method contains our component initialization code.
<2> Our component's initialization process will be idempotent. If
the _service_ field has already been set we'll return the current
component.
<3> The Pedestal service map contains Pedestal's configuration. It is
a component dependency and will be available during component
initialization.
<4> First we'll call the `create-server` function. This will
initialize the service provider and configure the default
interceptors.
<5> Invoke the start function to start the server. As you'll see
later, this function can simply be `identity` for testing purposes.
<6> Assoc the initialized service map onto the component as
`:service`. This is the only state the component needs to manage.

If you've read some of the other guides, this implementation should
look somewhat familiar. It's a combination of the server-specific code
used in the link:hello-world[Hello World guide].

Now let's implement the `stop` method.
----
include::component/src/pedestal.clj[tags=component-stop]
----
<1> The `stop` method contains our component teardown code.
<2> Like `start`, `stop` will be idempotent. If the component has
been initialized, we'll pass the initialized service map to the stop
function, otherwise we won't.
<3> Return the component with the _service_ field set to `nil`. This
is preferred over `dissoc` since `dissoc` would return a plain map
instead of a _Pedestal_ record.

Now that we've got our component, we need a way to
initialize it. Let's tackle that next.
----
include::component/src/pedestal.clj[tags=constructor]
----
Our constructor initializes the Pedestal component with start and
stop functions. As you'll see later. This is useful for testing purposes.

Now that we've got our Pedestal component, let's proceed to wiring it
into a full-fledged system.

== Wiring it up
Create a `routes.clj` file. This file will contain our routes and
handlers.

[source, clojure]
.src/routes.clj

----
include::component/src/routes.clj[tags=ns]
----
The _routes_ namespace has no dependencies.

Now let's implement a simple handler.
----
include::component/src/routes.clj[tags=response]
----
The `respond-hello` handler may look familiar. You first saw it in
the link:hello-world[Hello World guide]. It returns a simple, static
response.

Finally, let's implement the routes.
----
include::component/src/routes.clj[tags=routes]
----
We'll implement a single route, _/greet_, using Pedestal's Tabular
Routing syntax.

Now that we've got our Pedestal Component and routes, we can wire
them up in a Component system map.

Create a `system.clj` file. This file will contain our system map and
system constructor.

[source, clojure]
.src/system.clj

----
include::component/src/system.clj[tags=ns]
----
<1> Require `com.stuartsierra.component`. It will be used to  to
create the Component system map.
<2> Require `reloaded.repl` for it's system management functions.
<3> Require `io.pedestal.http` for the server _start_ and _stop_ functions.
<4> Require `pedestal` for the Pedestal component.
<5> Require `routes` for the application routes.

Let's create a system initialization function named _app_.
----
include::component/src/system.clj[tags=app]
----
<1> It will have two arities to support the option of passing in
start/stop functions.
<2> The system map will contain a `:service-map` key who's value is
a Pedestal service map.
<3> We'll configure the service map with our app-specific routes.
<4> The system map will contain a `:pedestal` key who's value is an
uninitialized Pedestal component.
<5> Pass the start/stop parameters to the Pedestal component
constructor.
<6> The Pedestal component depends on a service map, so will capture
that dependency with `component/using`.

== Running It
We'll use link:http://boot-clj.com/:[boot-clj] to run our
example. This should be familiar to you if you read through the
link:hello-world[Hello World guide].

Let's create a `build.boot` file so that we can fire up a boot repl.

[[app-listing]]
[source,clojure]
.build.boot
----
include::component/build.boot[]
----

From the project's root directory, fire up a repl, and start the system.
----
$ boot repl
...
boot.user=> (require 'reloaded.repl)
nil
boot.user=> (require 'system)
...
boot.user=> (reloaded.repl/go)
[nREPL-worker-2] INFO org.eclipse.jetty.util.log - Logging initialized @281159ms
[nREPL-worker-2] INFO org.eclipse.jetty.server.Server - jetty-9.3.8.v20160314
[nREPL-worker-2] INFO org.eclipse.jetty.server.handler.ContextHandler - Started o.e.j.s.ServletContextHandler@3017154a{/,null,AVAILABLE}
[nREPL-worker-2] INFO org.eclipse.jetty.server.ServerConnector - Started ServerConnector@2ce2b722{HTTP/1.1,[http/1.1, h2c, h2c-17, h2c-16, h2c-15, h2c-14]}{0.0.0.0:8890}
[nREPL-worker-2] INFO org.eclipse.jetty.server.Server - Started @281317ms
:started
----

You can now interact with the started service.
----
 $ curl -i http://localhost:8890/greet

HTTP/1.1 200 OK
Date: Sun, 11 Sep 2016 23:16:24 GMT
Strict-Transport-Security: max-age=31536000; includeSubdomains
X-Frame-Options: DENY
X-Content-Type-Options: nosniff
X-XSS-Protection: 1; mode=block
Content-Type: text/plain
Transfer-Encoding: chunked
Server: Jetty(9.3.8.v20160314)

Hello, world!%
----

To stop the system, invoke the `reloaded.repl/stop` function from the
repl.

----
boot.user=> (reloaded.repl/stop)
[nREPL-worker-3] INFO org.eclipse.jetty.server.ServerConnector - Stopped ServerConnector@2ce2b722{HTTP/1.1,[http/1.1, h2c, h2c-17, h2c-16, h2c-15, h2c-14]}{0.0.0.0:8890}
[nREPL-worker-3] INFO org.eclipse.jetty.server.handler.ContextHandler - Stopped o.e.j.s.ServletContextHandler@3017154a{/,null,UNAVAILABLE}
:stopped
----

== Testing
Let's move on to testing our new service. First create a
`system_test.clj` file in the `src` directory.

[source, clojure]
.src/system_test.clj

----
include::component/src/system_test.clj[tags=ns]
----
The _system-test_ namespace requires all the dependencies
necessary for testing.

Before we implement our test, we'll create some test helpers.

The `url-for` helper allows us to refer to routes by _route-name_.
----
include::component/src/system_test.clj[tags=url-for]
----
We need to expand the routes before invoking Pedestal's
`route/url-for-routes` function.

The `service-fn` helper extracts the Pedestal `::http/service-fn` from
the started system.
----
include::component/src/system_test.clj[tags=service-fn]
----

The `with-system` macro allows us to start/stop systems between test executions.
----
include::component/src/system_test.clj[tags=with-system]
----

We'll also need a test system constructor because we don't want to start an
http server and bind to a port.
----
include::component/src/system_test.clj[tags=test-system]
----
<1> Create the Pedestal Provider (Jetty Servlet in this case) but
don't start the server.
<2> Since we didn't start the server, there's nothing to stop.

Now that we've got our helpers implemented, let's move on to our
test. Create a test named `greeting-test`.
----
include::component/src/system_test.clj[tags=test]
----
<1> `sut` will be bound to the started system by `with-system`.
<2> Use the `service-fn` helper to extract the Pedestal service
function from the started system.
<3> Use Pedestal's `response-for` test helper to make a test request
to the `:greet` route. Use the `url-for` helper to refer to the route
by name.
<4> We should get back a '200' status.
<5> We should get back a response body of 'Hello, world!'

Now let's restart the repl and run our tests.
----
boot.user=> (require 'system-test)
nil
boot.user=> (clojure.test/run-tests 'system-test)

Testing system-test
[nREPL-worker-4] INFO io.pedestal.http - {:msg "GET /greet", :line 78}

Ran 1 tests containing 2 assertions.
0 failures, 0 errors.
{:test 1, :pass 2, :fail 0, :error 0, :type :summary}
----

That's it! You now know the fundamentals necessary for implementing
and testing your Component-based Pedestal services.

== The Whole Shebang
For reference, here are the complete contents of all the files.

[[app-listing]]
[source,clojure,subs="-callouts"]
.src/pedestal.clj
----
include::component/src/pedestal.clj[tags=ns]

include::component/src/pedestal.clj[tags=component-init]
include::component/src/pedestal.clj[tags=component-start]
include::component/src/pedestal.clj[tags=component-stop]

include::component/src/pedestal.clj[tags=constructor]
----


[[app-listing]]
[source,clojure,subs="-callouts"]
.src/routes.clj
----
include::component/src/routes.clj[tags=ns]

include::component/src/routes.clj[tags=response]

include::component/src/routes.clj[tags=routes]
----


[[app-listing]]
[source,clojure,subs="-callouts"]
.src/system.clj
----
include::component/src/system.clj[tags=ns]

include::component/src/system.clj[tags=app]

include::component/src/system.clj[tags=init]
----


[[app-listing]]
[source,clojure,subs="-callouts"]
.src/system_test.clj
----
include::component/src/system_test.clj[tags=ns]

include::component/src/system_test.clj[tags=url-for]

include::component/src/system_test.clj[tags=service-fn]

include::component/src/system_test.clj[tags=with-system]

include::component/src/system_test.clj[tags=test-system]

include::component/src/system_test.clj[tags=test]
----

[[app-listing]]
[source,clojure,subs="-callouts"]
.build.boot
----
include::component/build.boot[]
----
== What's next?

In a separate guide (coming soon!), we'll demonstrate how to introduce dependencies
and make them accessible to our handlers.

== In the wild
There are a number of implementations of Pedestal components in the
wild. Here are some examples. Be sure to check them out!

1. Stuart Sierra's
link::https://github.com/stuartsierra/component.pedestal[component.pedestal] repository
explores using Pedestal with Component and provides some great ideas
on how to make your component dependencies visible to Pedestal
interceptors and handlers.
2. Point Slope's
link::https://github.com/pointslope/elements[Elements] library
contains a Pedestal component based on some of the ideas implemented
in this guide. The implementation borrows the core ideas from 'component.pedestal'.
3. Michael Glaesemann's
link::https://github.com/grzm/component.pedestal[component.pedestal library], is a fork of
Stuart's
link::https://github.com/stuartsierra/component.pedestal[component.pedestal]
repository extended with helpers and separate components for the
Pedestal Server and Servlet.
